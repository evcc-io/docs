---
sidebar_position: 6
---

import Tag from "../../../../../src/components/Tag";

# Plugins

Plugins can be used to integrate devices and external data sources into evcc for which there is no direct support.
Plugins can be used for the following categories:

- `meter`: [PV, battery, grid, meters](./meters)
- `charger`: [Wallboxes](./chargers), [Smart switches](./smartswitches), [Heat pumps, heating rods](./heating)
- `vehicle`: [Vehicles](./vehicles)
- `tariff`: [Tariffs, forecasts](../tariffs)
- `circuit`: [Load management](../features/loadmanagement)

Additionally, plugins can also be used for the endpoints described in [Messaging](/docs/reference/configuration/messaging) for sending lifecycle events.

## Overview

evcc offers the following plugins:

- [Modbus Plugin](#modbus) - Plugin for reading from a Modbus-capable device.
- [MQTT Plugin](#mqtt) - Plugin for indirectly communicating with MQTT-capable devices via MQTT.
- [HTTP Plugin](#http) - Plugin that communicates with end devices via HTTP API.
- [Websocket Plugin](#websocket) - Plugin for receiving device data via its own web server. Can only be used for reading data.
- [SMA/Speedwire Plugin](#speedwire) - Plugin specifically for SMA devices that can communicate with the Speedwire protocol.
- [Go Plugin](#go) - Plugin that provides or receives values via a Go script.
- [JavaScript Plugin](#javascript) - Plugin that provides or receives values via a JavaScript script.
- [Shell Plugin](#shell) - Plugin that can execute a shell script to extract data or receive data for writing.
- [Meter Plugin](#meter-plugin) - Plugin to use another meter as a data source.

In addition to these integration plugins, there are also helper plugins that provide additional functions:

- [Const Plugin](#const) - Special plugin that simply returns a constant value.
- [Calc Plugin](#calc) - Meta-plugin for arithmetically linking outputs from other plugins.
- [Combined Plugin](#combined) - Meta-plugin specifically for `charger` to combine the boolean status values for the connected (_plugged_) and charging (_charging_) state into a single charging status.
- [Valid Plugin](#valid) - Meta-plugin for providing plugin values based on boolean validation.

### Syntax

Each plugin has an individual configuration schema.
It's important to know whether the plugin is used in a **reading** or **writing** context.
Some configuration parameters only make sense in a reading context, others only when used in writing mode.

For example, the following configuration can be used to integrate an MQTT plugin as a `meter`, where the current power consumption is read via the specified MQTT topic:

```yaml title="Example: MQTT Plugin for power values of a power meter"
meters:
  - name: imsys
    type: custom
    power:
      source: mqtt
      topic: "home/current/imsys/chn2/raw"
```

The plugin configuration schema always has the following structure:

```yaml {3,5-6,8}
- name: <name>
  type: custom
  <attr1>:
    source: <plugin>
    <p-attr1>: ...
    <p-attr2>: ...
    ....
  <attr2>:
    ....
```

Where `<name>` stands for the device name, `<attr1>` and `<attr2>` for one of the device-specific attributes described below, `<plugin>` for the plugin type and `<p-attr1>`, `<p-attr2>` for plugin-specific configurations (e.g. `source`, `topic` for plugins of type `mqtt`)

#### Reading

When reading data using a plugin, so-called _pipelines_ can be used.
These allow data to be extracted in a fine-grained manner from the plugin's output.
This makes it possible to process complex data structures such as JSON or XML and filter out the required information.
Possible parameters for data extraction are:

- `regex`: A regular expression to extract values from the received text.
- `jq`: A [jq](https://jqlang.github.io/jq/)-expression to extract values from JSON structures.
  The full syntax and possibilities can be found in the jq documentation.
- `quote`: Boolean value that wraps the input data in quotes before passing it to jq. This allows jq to process unquoted strings (e.g. from MQTT). For an MQTT value like `Charging`, you can use `quote: true` and `jq: '. == "Charging"'`.
- `unpack`: Converts values from other number representations, e.g. `hex`.
- `decode`: Decodes binary formats like `uint32`, `float32` etc.

#### Writing

When writing, parameters in the configuration can be replaced by placeholders.
The data is provided in the form `${var[:format]}`.
If format is not specified, the data is provided in the standard %v Go format.
The variables are replaced with the corresponding value before the plugin is executed.
Additionally, all functions of the Go Template Library can be used to perform more complex data transformations.

Depending on the device ([`meter`](#meter), [`charger`](#charger) or [`vehicle`](#vehicle)), different attributes can be read or set with plugins.

### Meter

Power meters are configured in the configuration section [`meters`](/docs/reference/configuration/meters).
Meters defined under `meters:` can be used at various places within the `site` configuration:

- `grid`: Grid meter
- `pv`: PV meter
- `battery`: Home battery meter
- `charge`: Meter for the charging power of the wallbox
- `aux`: Consumption meter for intelligent consumers
- `ext`: Additional meter, e.g. for load management or data collection

`power` is the only mandatory attribute that must be present in every `meter` definition, all other attributes are optional.

However, not all meter types support all plugin attributes:

- `limitsoc` and `batterymode` are used exclusively for battery meters (i.e. for `meter` referenced in `site.battery`).
- `currents`, `voltages` and `powers` are phase attributes that must be configured with exactly three plugin configurations each (in a YAML array) and can be used for grid meters (`grid`) and wallboxes (`charge`).

The following tables contain all attributes that can be provided by plugins when configured for `meter`.
When using the plugins, it's also important that they return the correct data type.
To convert to the required data type, the pipelines described in [Reading](#reading) can be used.

| Attribute | Type                | Required | Context       | Description                                                 |
| --------- | ------------------- | -------- | ------------- | ----------------------------------------------------------- |
| power     | float               | yes      | all           | Current power in W                                          |
| energy    | float               | no       | all           | Meter reading in kWh                                        |
| maxpower  | int                 | no       | `pv` (hybrid) | Maximum AC power in W                                       |
| soc       | int                 | no       | `battery`     | State of charge in %                                        |
| capacity  | float               | no       | `battery`     | Capacity in kWh                                             |
| powers    | [float,float,float] | no       | all           | Phase powers in W. For sign detection of unsigned currents. |
| currents  | [float,float,float] | no       | all           | Phase currents in A. For detecting active phases.           |
| voltages  | [float,float,float] | no       | all           | Phase voltages in V. For connection detection (1p/3p).      |

**Example**

In this example, the configuration of a meter is queried for the current electrical grid power via an HTTP call:

```yaml
meters:
  - name: volkszaehler
    type: custom
    power:
      source: http
      uri: http://zaehler.network.local:8080/api/data.json?from=now
      jq: .data.tuples[0][1]

site:
  meters:
    grid: volkszaehler
    ...
  ...
```

In addition to the attributes that plugins provide for reading evaluation, the following attributes are used by evcc to trigger actions:

| Attribute   | Type | Required | Context   | Description                                                                                                                                                       |
| ----------- | ---- | -------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| limitsoc    | int  | no       | `battery` | Set charging target for battery in %. The charging target is calculated from the configured `MinSoc`, `MaxSoc` and the current state of charge (attribute `soc`). |
| batterymode | int  | no       | `battery` | Set charging mode directly (1: normal, 2: hold, 3: charge)                                                                                                        |

### Charger {#charger}

Wallboxes and chargers have the following attributes that can be read:

| Attribute   | Type                | Required | Description                                                 |
| ----------- | ------------------- | -------- | ----------------------------------------------------------- |
| status      | string              | yes      | Status (A..F)                                               |
| enabled     | bool                | yes      | Is charging enabled?                                        |
| power       | float               | no       | Charging power in W                                         |
| energy      | float               | no       | Meter reading in kWh                                        |
| identify    | string              | no       | Current RFID identifier                                     |
| soc         | int                 | no       | State of charge in %                                        |
| phases      | int                 | no       | Number of physical phases (1..3)                            |
| powers      | [float,float,float] | no       | Phase powers in W. For sign detection of unsigned currents. |
| currents    | [float,float,float] | no       | Phase currents in A. For detecting active phases.           |
| voltages    | [float,float,float] | no       | Phase voltages in V. For connection detection (1p/3p).      |
| temp        | float               | no       | Current temperature in °C (heating)                         |
| templimit   | int                 | no       | Temperature limit in °C (heating)                           |
| getmode     | int                 | no       | SG-Ready mode (heat pump)                                   |
| getmaxpower | float               | no       | Maximum heating power in W (heating)                        |

#### General Configuration Options {#charger-config}

In addition to plugin attributes, the following configuration options can be set directly on the charger:

| Attribute    | Type     | Required | Description                                              |
| ------------ | -------- | -------- | -------------------------------------------------------- |
| icon         | string   | no       | Icon for display in the user interface                   |
| features     | []string | no       | Feature flags for special charger properties (see below) |
| standbypower | int      | no       | Standby power in W (for `switchsocket` type)             |

##### Feature Flags {#charger-features}

The `features` array can be used to activate special charger properties:

| Feature          | Description                                                                                                                            |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| heating          | Treat device as heating (e.g. heat pump, heating rod). Affects display in the user interface.                                          |
| integrateddevice | Device without charging sessions and without connected vehicle (e.g. smart switch, permanently installed consumers).                   |
| coarsecurrent    | Charging current can only be set in 1 A steps (considered in the control logic).                                                       |
| welcomecharge    | Enable Welcome Charge function. Charger briefly supplies power when connecting, so the vehicle recognises that the charger is working. |

**Example with Features**:

```yaml
chargers:
  - name: heating-rod
    type: custom
    features:
      - heating
      - integrateddevice
    icon: heater
    status:
      source: mqtt
      topic: heater/status
    # ... additional attributes
```

**Example**

This example shows how to query the charging status (charging/not charging) of a charger via the Modbus plugin:

```yaml
chargers:
  - name: icharge
    type: custom
    enabled:
      source: modbus
      id: 4711
      uri: modbus.local:502
      rtu: false
      register:
        address: 100
        type: holding
        decode: uint16
```

In addition to read-only values, actions can also be triggered or configuration values set via plugins:

| Attribute       | Type  | Required | Description                                            |
| --------------- | ----- | -------- | ------------------------------------------------------ |
| enable          | bool  | yes      | Enable / disable charging                              |
| maxcurrent      | int   | yes      | Set maximum charging current in A                      |
| maxcurrentmilis | float | no       | Set maximum charging current in A                      |
| phases1p3p      | int   | no       | Perform phase switching (requires `tos: true`)         |
| wakeup          | bool  | no       | Wake up vehicle                                        |
| setmode         | int   | no       | Change SG-Ready mode (1: reduced, 2: normal, 3: boost) |
| setmaxpower     | int   | no       | Set maximum heating power in W (heating)               |

**Example**

This example switches a Tasmota socket via an MQTT message:

```yaml
chargers:
  - name: unu-charger
    type: custom
    enable:
      source: mqtt
      broker: mosquitto.local:883
      topic: cmd/unu-switch/Power
      payload: ON
```

### Vehicle {#vehicle}

Vehicle parameters can also be read via plugins.

| Attribute     | Type   | Required | Description                    |
| ------------- | ------ | -------- | ------------------------------ |
| soc           | int    | yes      | State of charge in %           |
| limitsoc      | int    | no       | Charge limit in %              |
| status        | string | no       | Status (A..F)                  |
| range         | int    | no       | Range in km                    |
| odometer      | int    | no       | Odometer reading in km         |
| climater      | bool   | no       | Climate control active?        |
| getmaxcurrent | float  | no       | Maximum charging current in A  |
| finishtime    | string | no       | Planned charging end (RFC3339) |

#### General Configuration Options {#vehicle-config}

The following configuration options can be set directly on the vehicle:

| Attribute | Type   | Required | Description                                       |
| --------- | ------ | -------- | ------------------------------------------------- |
| title     | string | no       | Display name of the vehicle in the user interface |
| icon      | string | no       | Icon for display in the user interface            |
| capacity  | float  | no       | Battery capacity in kWh                           |

**Example**

In the following example, the current range of the vehicle is read from MQTT messages:

```yaml
vehicles:
  - name: mazda
    type: custom
    title: Green Mazda
    capacity: 50
    range:
      source: mqtt
      topic: mazda2mqtt/c53/chargeInfo/drivingRangeKm
```

Additionally, special commands can be sent to the vehicle via plugins:

| Attribute    | Type | Required | Description                       |
| ------------ | ---- | -------- | --------------------------------- |
| wakeup       | bool | no       | Wake up vehicle                   |
| chargeenable | bool | no       | Start/stop charging process       |
| maxcurrent   | int  | no       | Set maximum charging current in A |

**Example**

To wake up a car via an HTTP ping to send further queries, the HTTP plugin can be used as in the following example:

```yaml
vehicles:
  - name: model-y
    type: custom
    wakeup:
      source: http
      uri: http://teslalogger.local:5000/command/08154711/wake_up
```

#### Charge Mode on Vehicle Identification

For user-defined vehicles, the charge mode can be configured with `onIdentify` to be set automatically when the vehicle is identified.
This is useful when you want the desired charge mode to be set automatically as soon as the vehicle is detected.

**Example**:

```yaml
vehicles:
  - name: my-car
    type: custom
    soc:
      source: mqtt
      topic: car/soc
    onIdentify:
      mode: pv
```

Available modes are: `off`, `now`, `minpv`, `pv`.

### Tariffs & Forecasts

See [Tariffs & Forecasts > Custom Plugin](../tariffs#plugin) for more details.

### Load Management

:::note Work in Progress
...
:::

### Messaging

:::note Work in Progress
...
:::

## Plugins

The following plugins are available and can be configured for the above-described attributes to enable flexible integration with various systems.

### Modbus <Tag label="read" category="read" /> <Tag label="write" category="write" /> {#modbus}

The `modbus` plugin can read data from any Modbus-capable device or SunSpec-compatible inverter.
Many power meters are already pre-configured (see [MBMD Supported Devices](https://github.com/volkszaehler/mbmd#supported-devices)).
It's also possible to write Modbus registers to integrate additional wallboxes.

See the [Modbus Documentation](/docs/reference/modbus) for more details.

### MQTT <Tag label="read" category="read" /> <Tag label="write" category="write" /> {#mqtt}

The `mqtt` plugin enables reading values via MQTT topics.
This is particularly useful for power meters, e.g. when they already provide their data via MQTT.
See the [MBMD Documentation](https://github.com/volkszaehler/mbmd) for an example of how to get Modbus measurement data into MQTT.
The plugin also offers the ability to read or parse JSON data structures via jq-like queries (see [HTTP plugin](#http)).

**Reading Example**:

```yaml
source: mqtt
topic: mbmd/sdm1-1/Power
timeout: 30s # don't accept values older than timeout
scale: 0.001 # factor applied to result, e.g. for Wh to kWh conversion
```

For write access, the data is provided with the `payload` attribute.
If this parameter is missing from the configuration, the value is written in the default format.

**Writing Example**:

```yaml
source: mqtt
topic: mbmd/charger/maxcurrent
payload: ${var:%d}
```

### HTTP <Tag label="read" category="read" /> <Tag label="write" category="write" /> {#http}

The `http` plugin performs HTTP calls to read or update data.
It also includes the ability to read or perform simple transformations on JSON data structures via jq queries (e.g. for REST APIs).
The full functionality can be found in the [official jq documentation](https://jqlang.github.io/jq/manual/).

Authentication methods are `basic`, `bearer` and `digest`.
The names of the respective parameters can be found [here](https://github.com/evcc-io/evcc/blob/master/plugin/http_auth.go#L23).

#### Authentication {#http-auth}

Various authentication methods are available for HTTP requests:

**Basic Authentication**:

```yaml
auth:
  type: basic
  user: <username>
  password: <password>
```

**Bearer Token** (e.g. for JWT):

```yaml
auth:
  type: bearer
  token: <token>
```

**Digest Authentication**:

```yaml
auth:
  type: digest
  user: <username>
  password: <password>
```

**Custom Authentication**:

For more complex authentication scenarios, custom authentication plugins can be developed.
These are integrated via the `source` parameter:

```yaml
auth:
  source: <plugin-name>
  user: <username>
  password: <password>
  # additional plugin-specific parameters
```

This allows integration of devices with special authentication requirements without having to modify the entire HTTP plugin code.

:::important Important
XML documents are automatically converted to JSON format internally, which can then be filtered with jq like a native JSON response.
Attributes get the prefix `attr`.
:::

:::tip
For testing jq queries, online tools like https://jqplay.org/ and for regex tests tools like https://regex101.com/ are useful.
:::

**Reading Example**:

```yaml
source: http
uri: https://volkszaehler/api/data/<uuid>.json?from=now
method: GET # default HTTP method
headers:
  - content-type: application/json
auth: # basic authentication
  type: basic
  user: foo
  password: bar
insecure: false # set to true to trust self-signed certificates
jq: .data.tuples[0][1] # parse response json
scale: 0.001 # factor applied to result, e.g. for kW to W conversion
cache: 60s # response cache duration
timeout: 10s # timeout in golang duration format, see https://golang.org/pkg/time/#ParseDuration
```

```yaml
source: http
uri: http://charger/status
jq: .total_power > 10 # Converts a json integer to a boolean value
```

**Writing Example**:

```yaml
body: %v # only applicable for PUT or POST requests
```

```yaml
enable:
  source: http
  uri: "http://charger/relay/0?turn={{if .enable}}on{{else}}off{{end}}"
```

### Websocket <Tag label="read" category="read" /> {#websocket}

The `websocket` plugin provides a WebSocket listener.
It also includes the ability to read or parse JSON data structures via jq-like queries.
This can be used, for example, to receive data from Volkszähler's push server.

**Reading Example**:

```yaml
source: http
uri: ws://<volkszaehler host:port>/socket
jq: .data | select(.uuid=="<uuid>") .tuples[0][1] # parse message json
scale: 0.001 # factor applied to result, e.g. for Wh to kWh conversion
timeout: 30s # error if no update received in 30 seconds
```

### SMA/Speedwire <Tag label="read" category="read" /> {#speedwire}

The `sma` plugin provides an interface to SMA devices that support the Speedwire protocol.

**Reading Example**:

```yaml
source: sma
uri: 192.168.4.51 # alternative to serial
serial: 123456 # alternative to uri
value: ActivePowerPlus # ID of value to read
password: "0000" # optional (default: 0000)
interface: eth0 # optional
scale: 1 # optional scale factor for value
```

Supported values for `value` can be found in the diagnostic output using the `evcc meter` command (with configured SMA `meter` devices).

All possible values can be found as constants [here](https://gitlab.com/bboehmke/sunny/-/blob/master/values.go#L24) (use the constant name for `value`).

### Go <Tag label="read" category="read" /> <Tag label="write" category="write" /> {#go}

The `go` plugin uses the [Yaegi](https://github.com/traefik/yaegi) interpreter to execute Go code at runtime.
It's particularly useful for type-safe calculations and complex data processing logic.

#### Available Go Standard Libraries

The following Go packages are automatically available and don't need to be imported:

- `fmt` - Formatted I/O
- `math` - Mathematical functions
- `strings` - String manipulation
- `time` - Time and date functions

**Reading Example**:

```yaml
source: go
script: |
  res := 500.0
  res * 2 // returns 1000.0
```

**Example with Time Functions**:

```yaml
source: go
script: |
  hour := time.Now().Hour()
  price := 50.0 // Night tariff
  if hour >= 9 && hour < 17 {
    price = 100.0 // Tariff price during business hours
  }
  price
```

**Example with String Processing**:

```yaml
source: go
script: |
  text := "hello world"
  strings.ToUpper(text) // returns "HELLO WORLD"
```

When the `go` plugin is used for writing, the value to be written is passed to the script as a variable:

**Writing Example**:

```yaml
charger:
  - type: custom
    maxcurrent:
      source: go
      script: |
        fmt.Printf("Setting charge current: %d A\n", maxcurrent)
        // maxcurrent variable is automatically available
```

#### Using Input Transformations

The `in` parameter allows you to use values from other sources as variables in your script.
This example shows conditional logic that cannot be achieved with simple Calc operations:

```yaml
power:
  source: go
  script: |
    // Power based on SoC and standby
    power := 5000.0 // normal
    if standby {
      power = 0.0 // no load in standby
    } else if soc < 20.0 {
      power = 1000.0 // low
    }
    power
  in:
    - name: soc
      type: float
      config:
        source: const
        value: 85.0
    - name: standby
      type: bool
      config:
        source: const
        value: false
```

### JavaScript <Tag label="read" category="read" /> <Tag label="write" category="write" /> {#javascript}

evcc integrates a JavaScript interpreter with the [Underscore.js](https://underscorejs.org) library, which is directly accessible via `_.`, e.g. `_.random(0,5)`.
The `js` plugin can execute JavaScript code via the `script` parameter. Very helpful for rapid prototyping:

**Reading Example**:

```yaml
source: js
script: |
  var res = 500;
  2 * res; // returns 1000
```

When the `js` plugin is used for writing, the value to be written is passed to the script as a variable:

**Writing Example**:

```yaml
charger:
  - type: custom
    maxcurrent:
      source: js
      script: |
        console.log(maxcurrent);
```

### Shell Script <Tag label="read" category="read" /> <Tag label="write" category="write" /> {#shell}

The `script` plugin executes external scripts to read or update data. The plugin is useful for integrating any kind of external functionality.

**Reading Example**:

```yaml
source: script
cmd: /bin/bash -c "cat /dev/urandom"
timeout: 5s
```

**Writing Example**:

```yaml
source: script
cmd: /home/user/my-script.sh ${enable:%b} # format boolean enable as 0/1
timeout: 5s
```

### Const <Tag label="read" category="read" /> {#const}

The `const` plugin returns a constant value.
It's suitable, for example, to apply fixed correction values (offset) to a variable value in conjunction with the `calc` plugin or to simulate measurement and status values for testing purposes.

**Reading Example**:

```yaml
source: const
value: -16247
```

### Calc <Tag label="read" category="read" /> {#calc}

The `calc` plugin allows mathematical processing of multiple individual values:

**Reading Example**:

```yaml
source: calc
add:
- source: ...
  ...
- source: ...
  ...
```

```yaml
source: calc
mul:
- source: calc
  sign:
    source: ... (power)
  ...
- source: ... (current)
  ...
```

The basic arithmetic operations addition (add), multiplication (mul), division (div), sign inversion (sign), absolute value (abs), minimum value (min) and maximum value (max) are supported as operands.

With `scale: -1` on one of the values, simple subtraction can be performed, with `scale: 0.001` division, e.g. for converting kWh to Wh.

With `sign:` (every positive number becomes +1, every negative number becomes -1, 0 remains 0), signs can be transferred to other values (in conjunction with `mul`).
E.g. to transfer the "direction" of power (feed-in or consumption) to the measured currents for meters.

With `abs:`, the absolute value of a number is calculated.

With `min:` and `max:` the minimum value respectively the maximum value will be calculated.

The `calc` plugin is helpful for e.g.

- Summing power values from individual PV strings (addition)
- Calculating apparent power from voltage and current (multiplication)
- Combining separate power values for import and export into a signed single value (subtraction).
- Calculating percentage fill levels (division)
- Determining the correct direction of current flow (sign)
- Eliminating known offsets (addition with `const` plugin)

:::tip
Constant auxiliary values (e.g. for offsets) can be generated as operands using the `const` plugin.
:::

### Combined <Tag label="read" category="read" /> {#combined}

The `combined` status plugin is used to convert mixed boolean status values of `Plugged` (connected) / `Charging` (charging) into an evcc-compatible charging status of A..F.
It's used, for example, with an OpenWB MQTT integration.

**Reading Example**:

```yaml
source: combined
plugged:
  source: mqtt
  topic: openWB/lp/1/boolPlugStat
charging:
  source: mqtt
  topic: openWB/lp/1/boolChargeStat
```

### Valid <Tag label="read" category="read" /> {#valid}

The `valid` plugin allows providing plugin values based on boolean validation.
It separates the validity of a value from its actual content.
If the validation returns `false`, the value is considered unavailable.

This is particularly useful for integrations like ioBroker that provide validity and value separately.

**Reading Example**:

```yaml
source: valid
valid:
  source: mqtt
  topic: iobroker/wallbox/power/valid
value:
  source: mqtt
  topic: iobroker/wallbox/power/value
```

In this example, the value is only used when the `valid` topic returns `true`.
If it returns `false`, the value is marked as unavailable.

### Meter <Tag label="read" category="read" /> {#meter-plugin}

The `meter` plugin allows using another meter as a data source.
This is useful when you want to use an existing device for multiple measurements or when you need different methods of a device for different attributes.

The `config` section contains the complete template configuration of the meter to be embedded.

**Reading Example**:

```yaml
meters:
  - name: battery
    type: custom
    power:
      source: meter
      config:
        type: template
        template: shelly-1pm
        host: 192.168.178.21
        channel: 0
      method: power
      scale: -1
    energy:
      source: meter
      config:
        type: template
        template: shelly-1pm
        host: 192.168.178.21
        channel: 0
      method: energy
    soc:
      source: mqtt
      topic: Haus/Batterie
      jq: .soc
      timeout: 60s
```

In this example, a Shelly 1PM device is used as a data source for power and energy of a battery, while the state of charge (SoC) is retrieved via MQTT.
